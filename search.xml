<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>第二章信息的表示和处理</title>
      <link href="/2022/12/21/csapp-di-er-zhang-xin-xi-de-biao-shi-he-chu-li/"/>
      <url>/2022/12/21/csapp-di-er-zhang-xin-xi-de-biao-shi-he-chu-li/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/12/15/csapp-di-yi-zhang-ji-suan-ji-xi-tong-man-you/"/>
      <url>/2022/12/15/csapp-di-yi-zhang-ji-suan-ji-xi-tong-man-you/</url>
      
        <content type="html"><![CDATA[<h1 id="cs-app-第一章-计算机系统漫游"><a href="#cs-app-第一章-计算机系统漫游" class="headerlink" title="cs:app 第一章 计算机系统漫游"></a>cs:app 第一章 计算机系统漫游</h1> <div class="wb"><div class="t">  </div><div class="c">本章总的来说是本书的一个引入，通过我们所写的一个.c文件由书写到执行的全过程中所经历的历程，从而对于计算机系统的总体进行一个一个大致的描述，和概念的提出，起到一个抛砖引玉的效果。     </div> </div><h3 id="1-1信息就是位-上下文"><a href="#1-1信息就是位-上下文" class="headerlink" title="1.1信息就是位+上下文"></a>1.1信息就是位+上下文</h3><p>这里提到了信息是由位+上下文。那么什么是位呢？什么又是上下文呢？</p><p>我们的所写的程序，本质上都是由值0和1组成的位（bit 比特）。这就是所谓的位，而8个位组成一组，我们称之为字节。而字节可以表示程序的一些文本字符，一群文本字符的集合构成了我们的程序。</p><blockquote><p>大部分的现代计算机系统都使用ASCII标准来表示文本字符。只由ASCII字符构成的文件称为文本文件，所有其他文件都称为二进制文件。</p></blockquote><p>到此我们可以知道了，我们数据就是一串串的比特来表示的。然而面对众多数据，例如：我们的程序数据，我们网上邮箱的数据，我们打游戏而储存的数据……等等，如何区别这些信息（数据）呢？这个时候就需要了解这些数据对象的上下文。在不同的的上下文中，同一个数据，可能表示为数值，可能表示字符串（英文，汉字等），也可能表示某条指令。</p><p>因此我们说位（比特）与该数据对象的上下文构成了信息。</p><h3 id="1-2程序被其他程序翻译成不同的格式"><a href="#1-2程序被其他程序翻译成不同的格式" class="headerlink" title="1.2程序被其他程序翻译成不同的格式"></a>1.2程序被其他程序翻译成不同的格式</h3><p>对于我们写的第一个程序hello，我们得到的是hello.c的文件，而要到我们所执行的hello.exe可执行文件就需要经过一系列的路程，在这个过程中我们的程序就会被翻译成不同的格式。</p><p><img lazyload="" src="/images/loading.svg" data-src="/2022/12/15/csapp-di-yi-zhang-ji-suan-ji-xi-tong-man-you/image-20221214130847881.png" alt="image-20221214130847881"></p><p>具体有四个过程：</p><ul><li>预处理阶段。将我们.c文件里面的对#开头的命令，例如引用的文件，define 的数据等，插入到文本中，得到.i文件。</li><li>编译阶段。编译器将我们的.i文本翻译成汇编语言。文件由.i变成.s.</li><li>汇编阶段。汇编器将我们的.s文本翻译成机器语言指令（0，1），如何把这些指令打包成可重定位目标程序。到这里.s文件变成了.o文件。这里得到的.o文件属于二进制文件。</li><li>链接阶段。在我们程序中引用了c语言的库函数。而这个时候链接器就将我们引用的库函数，链接合并到我们的文件中。到此处.o文件转化成了.exe文件。</li></ul><p>.exe就可以加载到内存中，由系统执行了。</p><h3 id="1-3了解编译系统的益处"><a href="#1-3了解编译系统的益处" class="headerlink" title="1.3了解编译系统的益处"></a>1.3了解编译系统的益处</h3><ul><li>优化程序性能</li><li>理解链接时出现的错误</li><li>避免安全漏洞</li></ul><h3 id="1-4处理器读并解释储存在内存中的指令"><a href="#1-4处理器读并解释储存在内存中的指令" class="headerlink" title="1.4处理器读并解释储存在内存中的指令"></a>1.4处理器读并解释储存在内存中的指令</h3><p>当我们运行.exe文件的时候，这个时候就需要我们的系统进行进行执行，而我们的系统是由硬件组成的，在的硬件配合才能成功的执行我们的.exe文件。首先这里我们要了解我们系统的硬件组成，以及其运行原理。</p><p><strong>硬件组成</strong></p><ol><li><p><strong>总线</strong></p><p>贯穿整个系统的是一组电子管道，称作总线，它 携带信息字节并负责在各个部件间传递。</p></li></ol><p>总线就像我们的公路一般，起到连接作用。</p><ol start="2"><li><p><strong>I/O设备</strong></p><p>I/O（即in与out的缩写，输入/输出），I/O设备就是我们与计算机进行交互的通道。常见的输入设备：鼠标，键盘，USB..等等；输出设备：显示屏，磁盘驱动器。</p><p>这里需要提到的是每个I/O设备都通过一个控制器与适配器与I/O总线相连。控制器与适配器的区别。</p><blockquote><p>控制器是I/O设备本身或者系统的主印制电路板（主板）：适配器是一块插在主板插槽上的卡。</p></blockquote><p>3.<strong>主存</strong></p><p>主存是一个临时储存设备，在程序运行时用来存放程序和程序处理的数据。这个就像是我们做菜的菜板，将要处理的东西临时的放在上面。</p><p>4.<strong>处理器</strong></p><p>中央处理单元（cpu）,即为处理器。作用是解释或者执行存储在主存中的指令引擎。而它的核心是寄存器，又称程序计数器。它的特点是时刻指向主存中的某条机器语言指令。处理器从通电开始，就时刻的在执行寄存器指向的指令。CPU在指令的要求下大致会执行一下操作：</p><blockquote><ul><li><strong>加载</strong> ：从主存复制一个字节或者一个字到寄存器中，以覆盖寄存器原来的内容。</li><li><strong>存储</strong> ：从寄存器复制一个字符或者一个字到主存的某个位置，以覆盖寄存器原来的内容。</li><li><strong>操作</strong> ：把两个寄存器的内容复制到ALU（算术/逻辑单元），ALU对这两个字做算术运算，并将结果存放到一个寄存器中，以覆盖该寄存器中原来的内容。</li><li><strong>跳转</strong>：从指令本身中抽取一个字，并将这个字复制到程序计数（PC）中，以覆盖PC中原来的值。</li></ul></blockquote></li></ol><p>上面就是对于主要硬件的大致介绍，通过硬件的配合，我们的程序就能运行起来了。</p><h3 id="1-5高速缓存至关重要"><a href="#1-5高速缓存至关重要" class="headerlink" title="1.5高速缓存至关重要"></a>1.5高速缓存至关重要</h3><p>为什么说高速缓存至关重要呢？通过上面硬件的流程我们可以知道，程序的机器指令到运行的时候，要经过多次复制，为了提高性能，系统设计者需要设计一个东西使得复制操作尽快完成。然而加快处理器的运行速度比加快主存的运行速度要容易和便宜得多，也就说优化处理器性价比更高，从而系统设计者采用了高速缓存存储器（高速缓存），利用高速缓存的局部性原理，来提高性能。因而我们能够利用高速缓存将程序的性能提高一个数量级。</p><h3 id="1-6存储设备形成层次结构"><a href="#1-6存储设备形成层次结构" class="headerlink" title="1.6存储设备形成层次结构"></a>1.6存储设备形成层次结构</h3><p>计算机系统的存储设备都被组织成了一个存储器层次结构，如图，从上到下设备的访问速度越来越慢，而容量越来越大，造价也越来越便宜。</p><p><img lazyload="" src="/images/loading.svg" data-src="/image-20221214181429916.png" alt="image-20221214181429916"></p><p>我们可以通过利用对整个存储器层次结构的理解来提高程序性能。</p><h3 id="1-7操作系统管理硬件"><a href="#1-7操作系统管理硬件" class="headerlink" title="1.7操作系统管理硬件"></a>1.7操作系统管理硬件</h3><p>当我们运行输入命令或者运行程序的时候，其实他们并不是直接去访问我们的硬件的（键盘，显示器 等），而是需要通过一个“媒介”——操作系统。可以这样说，所有应用程序对应硬件的操作尝试都通过操作系统。这里的操作系统就好比一个对于程序与硬件的管理者，一个方面防止硬件被失控的应用程序滥用，另一方面向应用程序提供简单一致的机制来控制复制而又不相同的低级硬件设备。而操作系统通过，进程，虚拟内存，文件，这三个方面实现的。</p><h6 id="进程与线程"><a href="#进程与线程" class="headerlink" title="#进程与线程"></a>#进程与线程</h6><p>什么是进程呢？所谓进程就是操作系统对于一个正在运行的程序的一种抽象，换个方式来理解，一个程序从开始运行到结束这个过程，就是进程。而进程又是由线程组成的，线程指的就是我们程序里面一个个的执行单元。举个例子，当你打开音乐播放器，将音乐播放器运行起来，这个时候，就相当于一个进程，这个时候，你想听歌，这就相当于一个线程，如果你想在听歌的时候同时把歌曲下载下来，这个时候就变成了所谓的多线程。</p><h6 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="#虚拟内存"></a>#虚拟内存</h6><p>我们都知道我们的内存是有限，当我们运行多个进程的时候，就有可能出现主存不足的情况，因此虚拟空间就出现了。虚拟空间的作用就是创建一个更大的连续的空间——利用一部分磁盘的空间。由于是由主存和磁盘上空间上的，物理上并不是连续的，但是逻辑是连续的，虚拟一词就由此而来。</p><p>虚拟空间大致组成就如下图一般：</p><p><img lazyload="" src="/images/loading.svg" data-src="/image-20221216233613136.png" alt="image-20221216233613136"></p><blockquote><ul><li><strong>程序代码和数据</strong> 。正如其名，这里面就是我们所写的代码和一些数据。</li><li><strong>堆</strong> 这里是我们个人可以管理的空间，比如，c语言中的malloc申请一片空间，free释放一片空间。</li><li><strong>共享库</strong> 这里面存放的是我们的一些c语言库，数学库等等，一些库的代码和数据。</li><li><strong>栈</strong> 这是由编译器管理的空间。存储着我们调用的函数，设置的变量和一些对象的引用，等等，由编译器分配。</li><li><strong>内核存虚拟内存</strong> 系统内核区域</li></ul></blockquote><h6 id="文件"><a href="#文件" class="headerlink" title="#文件"></a>#文件</h6><p>文件就是字节序列。就是一堆0,1构成的的集合体。万物皆文件，在系统里面的所有数据我们都可以称之为文件。</p><h3 id="1-8系统之间利用网络通信"><a href="#1-8系统之间利用网络通信" class="headerlink" title="1.8系统之间利用网络通信"></a>1.8系统之间利用网络通信</h3><p>我们的个人计算机，就是一个单独的系统，然而我们的计算机可以通过网络实现对于其他计算机的连接，这样我们单独的系统就可以连进一个大家庭了。利用网路完成信息的交互。实现上网。</p><p>比如我们去b站看视频。大致过程就是，我们本地的客户端，向着远程的服务端进行传输数据，发送我们的视频请求，服务端接收到数据之后，经过一系列的操作，将我们所请求的视频数据返回到我们本地的客服端，我们接收之后，客户端进行操作，然后显示到我们的显示屏上，这样我们就可以看到视频的内容了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/12/15/xin-pian-zhang/"/>
      <url>/2022/12/15/xin-pian-zhang/</url>
      
        <content type="html"><![CDATA[<h2 id="第一次搭建博客记录一下"><a href="#第一次搭建博客记录一下" class="headerlink" title="第一次搭建博客记录一下"></a>第一次搭建博客记录一下</h2><p>2022.12.15，记录一下二木的博客小屋的诞生。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
