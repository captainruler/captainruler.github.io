<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>csapp 第七章 链接</title>
      <link href="/2022/12/27/di-qi-zhang-lian-jie/"/>
      <url>/2022/12/27/di-qi-zhang-lian-jie/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>csapp 第三章 程序的机器级表示</title>
      <link href="/2022/12/24/csapp-di-san-zhang-cheng-xu-de-ji-qi-ji-biao-shi/"/>
      <url>/2022/12/24/csapp-di-san-zhang-cheng-xu-de-ji-qi-ji-biao-shi/</url>
      
        <content type="html"><![CDATA[<h3 id="程序编码"><a href="#程序编码" class="headerlink" title="程序编码"></a>程序编码</h3><ul><li>反汇编器是通过机器代码文件中的字节序列来确定汇编代码的。有着特点的机器码，例如：E8就代表call指令</li></ul><h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><ul><li>字—word，双字—double words ，四字—quad words</li><li><img lazyload="" src="/images/loading.svg" data-src="/2022/12/24/csapp-di-san-zhang-cheng-xu-de-ji-qi-ji-biao-shi/image-20221227230758891.png" alt="image-20221227230758891"></li></ul><h3 id="访问信息"><a href="#访问信息" class="headerlink" title="访问信息"></a>访问信息</h3><ul><li>一般局部变量是放在寄存器中的，二不是内存中，因为访问寄存器比访问内存要快得多</li><li>栈是一种数据结构，可以添加或者删除数据，但是必须遵守的是“先进后出原则”。相当于一个口管理进出，而这个删除和存入的这一个口，我们叫栈顶。</li></ul><h3 id="算数和逻辑操作"><a href="#算数和逻辑操作" class="headerlink" title="算数和逻辑操作"></a>算数和逻辑操作</h3><ul><li>lea为加载有地址，作用是从内存读取数据到寄存器中。作用就是取地址。</li><li>一元操作与二元操作，就是有几个操作数的意思，比如，++i,就是一元，x+Y,就是二元。</li><li>test与and 的作用都是进行逻辑与的运算，test与and 的区别，test不会改变ax与bx的值，而and是ax与bx计算之后，然后将值存储在ax中。</li><li>跳转表是一个数组，表项i是一个代码段的地址，起到索引的作用。用跳转表的一大优点就是执行开关语句的时间与开关情况的数量无关。意思就是，判断一次，然后就直接执行了，而像if–else这类，就需要分别进行判断，然后才能执行。</li></ul><h3 id="数组分配和访问"><a href="#数组分配和访问" class="headerlink" title="数组分配和访问"></a>数组分配和访问</h3><ul><li><p>c语音允许指针进行运算，，*运算和&amp;运算， *与&amp;是可以相互抵消的。</p></li><li><p>二维数组在内存中排列的顺序是按照行优先的原则。列如数组A [5] [3]</p></li><li><p><img lazyload="" src="/images/loading.svg" data-src="/2022/12/24/csapp-di-san-zhang-cheng-xu-de-ji-qi-ji-biao-shi/image-20221227210346634.png" alt="image-20221227210346634"></p><p>这里可以联想到，一个一维数组可以省略其大小，而二维数组可以省略其行，但是不能省略其列。此时二维数组就可以看做一维数组的嵌套，一维数组必须声明其为什么数组,以表明其装载的数据是int还是char,表明其存储数据的大小，同理二维数组，一维数组的数组，使用里面的数组我们必须表明其大小，而一维数组的大小就是其有多少个数据，因此代表里层数组大小，也就是二维数组的列不能省略。</p><h3 id="异质的数据结构（c语言中的结构体和联合体）"><a href="#异质的数据结构（c语言中的结构体和联合体）" class="headerlink" title="异质的数据结构（c语言中的结构体和联合体）"></a>异质的数据结构（c语言中的结构体和联合体）</h3><ul><li><p><strong>结构体</strong> 将可能不同类型的对象聚合到一个对象中。结构体的所有组成部分都存放在内存的连续的区域内，指向结构体的指针是结构体第一个 字节的地址</p></li><li><p><strong>联合体</strong> 允许多种类型来引用一个对象，一个联合体的总大小为其最大字段的大小</p></li><li><p><strong>数据对齐</strong> 计算机系统要求某种类型对象的地址必须为2、4、8的倍数。（对于x86指令来说，保持数据对齐能提高效率）</p></li><li><p>大多数函数的栈帧的边界都必须是16字节的倍数<img lazyload="" src="/images/loading.svg" data-src="/image-20221227220154580.png" alt="image-20221227220154580"></p></li><li><p>在Linux系统中，栈随机化已经变成了标准行为，通过栈随机化使得栈的位置在程序每次运行时都有变化，以避免安全单一化。</p></li><li><p>栈破坏检测。栈保护者机制，在栈帧中任何局部缓冲区与栈状态之间存储一个特殊的金丝雀值，由程序运行时随机产生。原理是，在恢复寄存器和从函数返回之前，程序会检测金丝雀值是否被函数某个操作改变，若改变，程序便会异常终止。（一般用于栈溢出）</p><h3 id="浮点代码"><a href="#浮点代码" class="headerlink" title="浮点代码"></a>浮点代码</h3><ul><li>把浮点值转换成整数时，指令会执行截断，把值向零进行舍入</li></ul></li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>脱壳</title>
      <link href="/2022/12/21/tuo-ke/"/>
      <url>/2022/12/21/tuo-ke/</url>
      
        <content type="html"><![CDATA[<h1 id="对于脱壳一些题型的记录"><a href="#对于脱壳一些题型的记录" class="headerlink" title="对于脱壳一些题型的记录"></a>对于脱壳一些题型的记录</h1><p>对于手动脱壳，我们有两种常用的安全工具，一个是od,另一个是ida。两个方法略有不同。对于脱一般的程序壳的时候，我主要用的是ida来脱壳，一般ida实在脱不了了再想到用od来脱，od,，所以我记录的大多都是用的ida来脱的。</p><h3 id="大致步骤"><a href="#大致步骤" class="headerlink" title="大致步骤"></a>大致步骤</h3><h5 id="1、寻找oep"><a href="#1、寻找oep" class="headerlink" title="1、寻找oep"></a>1、寻找oep</h5><p>因为我们的壳经过运行之后，会慢慢的自动解开壳，我们就要去寻找解开后的那个时候的程序入口。而oep就是程序的入口。</p><h5 id="2、寻找到加密函数"><a href="#2、寻找到加密函数" class="headerlink" title="2、寻找到加密函数"></a>2、寻找到加密函数</h5><p>找到oep之后，运行下来，我们的程序就出来了。我们就可以去寻找了。string里面去寻找字符串，然后再跳到函数里面，去就可以直接分析了。</p><h5 id="3、dump与修复"><a href="#3、dump与修复" class="headerlink" title="3、dump与修复"></a>3、dump与修复</h5><p>有些时候，可能我们要将程序剥离出来，这个时候就在oep口的地方将全部程序dump出来即可，dump出来之后还要进行修复文件，因为它的程序地址那些会发生改变，因此我们需要修复IAT。</p><p><strong>对于脱壳运用最多的方法，一个是单步调试法，另一个就是ESP定律来脱壳</strong></p><h3 id="单步调试法"><a href="#单步调试法" class="headerlink" title="单步调试法"></a>单步调试法</h3><p>正如其名，单步调试法就是进行动态调试文件，分析汇编指令，找到关键点,寻找oep</p><h3 id="esp定律（堆栈平衡）"><a href="#esp定律（堆栈平衡）" class="headerlink" title="esp定律（堆栈平衡）"></a>esp定律（堆栈平衡）</h3><p>由于我们壳会在内存中还原程序，跳到oep，执行我们的程序。大致过程就是运行壳程序解壳，然后退出解壳程序，加载原本程序。有着壳程序的运行与退出，根据堆栈平衡原理，壳退出后，必然会操作堆栈指针为进入之前的堆栈指针。因此根据这个原理，我们可以在堆栈处，设置访问断点，让程序运行，当程序暂停的时候，就是壳程序即将执行完的时候，然后在其附近单步跟踪就可以找到原始OEP了。</p><h3 id="UPX"><a href="#UPX" class="headerlink" title="UPX"></a>UPX</h3><h3 id="题目一："><a href="#题目一：" class="headerlink" title="题目一："></a>题目一：</h3><h3 id="链接：https-pan-baidu-com-s-1teQgV5kgKpuNJ60o0byYVg-pwd-j8mj"><a href="#链接：https-pan-baidu-com-s-1teQgV5kgKpuNJ60o0byYVg-pwd-j8mj" class="headerlink" title="链接：https://pan.baidu.com/s/1teQgV5kgKpuNJ60o0byYVg?pwd=j8mj"></a>链接：<a class="link" href="https://pan.baidu.com/s/1teQgV5kgKpuNJ60o0byYVg?pwd=j8mj">https://pan.baidu.com/s/1teQgV5kgKpuNJ60o0byYVg?pwd=j8mj<i class="fas fa-external-link-alt"></i></a></h3><h3 id="提取码：j8mj"><a href="#提取码：j8mj" class="headerlink" title="提取码：j8mj"></a>提取码：j8mj</h3><h6 id="单步调试法-1"><a href="#单步调试法-1" class="headerlink" title="单步调试法"></a>单步调试法</h6><p><img lazyload="" src="/images/loading.svg" data-src="/2022/12/21/tuo-ke/image-20221221172644959.png" alt="image-20221221172644959"></p><p>这个jmp非常可疑（一般那种jmp有大跳转就要注意），我们在这里按下f2 下断点，运行之后，按f7跟入。</p><p><img lazyload="" src="/images/loading.svg" data-src="/2022/12/21/tuo-ke/image-20221221174102488.png" alt="image-20221221174102488"></p><p>到这里大致就可以猜出我们找对了。</p><p>按f8，运行到  jmp,f7跟入</p><p><img lazyload="" src="/images/loading.svg" data-src="/2022/12/21/tuo-ke/image-20221221175001632.png" alt="image-20221221175001632"></p><p>到这里就差不多知道找到oep了，由于这样ida没有将它分析出来，我们按p，将其分析出来</p><p><img lazyload="" src="/images/loading.svg" data-src="/2022/12/21/tuo-ke/image-20221221175423558.png" alt="image-20221221175423558"></p><p>进行反汇编之后发现看不懂，也没有找到我们的函数。这里有两个方法，一个就是单步，直到程序等待输入，另一个方法就是直接去string中搜索，字符串。我运用的是第二种。</p><p><img lazyload="" src="/images/loading.svg" data-src="/2022/12/21/tuo-ke/image-20221221203234327.png"></p><p><img lazyload="" src="/images/loading.svg" data-src="/2022/12/21/tuo-ke/image-20221221203609175.png" alt="image-20221221203609175"></p><p>按键盘上的X快捷键。<img lazyload="" src="/images/loading.svg" data-src="/2022/12/21/tuo-ke/image-20221221203438864-1671634100072-1.png" alt="image-20221221203438864-1671634100072-1"></p><p><img lazyload="" src="/images/loading.svg" data-src="/2022/12/21/tuo-ke/image-20221221203345394.png" alt="image-20221221203345394"></p><p>查询交叉引用就可以找到我们的加密函数，按f5反汇编即可。然后进行分析即可。</p><h3 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h3><h3 id="链接：https-pan-baidu-com-s-1-e-A7gJow71q4s8KYs0JfQ-pwd-fycv"><a href="#链接：https-pan-baidu-com-s-1-e-A7gJow71q4s8KYs0JfQ-pwd-fycv" class="headerlink" title="链接：https://pan.baidu.com/s/1_e_A7gJow71q4s8KYs0JfQ?pwd=fycv"></a>链接：<a class="link" href="https://pan.baidu.com/s/1_e_A7gJow71q4s8KYs0JfQ?pwd=fycv">https://pan.baidu.com/s/1_e_A7gJow71q4s8KYs0JfQ?pwd=fycv<i class="fas fa-external-link-alt"></i></a></h3><h3 id="提取码：fycv"><a href="#提取码：fycv" class="headerlink" title="提取码：fycv"></a>提取码：fycv</h3><p><img lazyload="" src="/images/loading.svg" data-src="/2022/12/21/tuo-ke/image-20221227095122670.png" alt="image-20221227095122670"></p><p>直接在程序的第一条指令上下一个断点。然后运行，寻找可疑点。</p><p><img lazyload="" src="/images/loading.svg" data-src="/2022/12/21/tuo-ke/image-20221227095328753.png" alt="image-20221227095328753"></p><p>指令的最后有个retn,这里我们按f4运行到此处，再按f7跟入。</p><p><img lazyload="" src="/images/loading.svg" data-src="/2022/12/21/tuo-ke/image-20221227095542230.png" alt="image-20221227095542230"></p><p>进入之后发现最后的jmp,我们继续像先前一样，f4,f7跟入。</p><p><img lazyload="" src="/images/loading.svg" data-src="/2022/12/21/tuo-ke/image-20221227095720390.png" alt="image-20221227095720390"></p><p>继续重复上面步骤。</p><p><img lazyload="" src="/images/loading.svg" data-src="/image-20221227095757480.png" alt="image-20221227095757480"></p><p>继续</p><p><img lazyload="" src="/images/loading.svg" data-src="/2022/12/21/tuo-ke/image-20221227095822799.png" alt="image-20221227095822799"></p><p>继续</p><p><img lazyload="" src="/images/loading.svg" data-src="/2022/12/21/tuo-ke/image-20221227095854783.png" alt="image-20221227095854783"></p><p><img lazyload="" src="/images/loading.svg" data-src="/2022/12/21/tuo-ke/image-20221227095925714.png" alt="image-20221227095925714"></p><p><img lazyload="" src="/images/loading.svg" data-src="/2022/12/21/tuo-ke/image-20221227095948589.png" alt="image-20221227095948589"></p><p>跟到了这里我们就大致可以知道了，我们马上成功了，我们找到了oep。继续</p><p><img lazyload="" src="/images/loading.svg" data-src="/2022/12/21/tuo-ke/image-20221227103349134.png" alt="image-20221227103349134"></p><p>到这里之后按p分析，就成了现在的样子，到这里就找到了我们的oep了。</p><p><img lazyload="" src="/images/loading.svg" data-src="/2022/12/21/tuo-ke/image-20221227103532762.png" alt="image-20221227103532762"></p><p><img lazyload="" src="/images/loading.svg" data-src="/2022/12/21/tuo-ke/image-20221227103552479.png" alt="image-20221227103552479"></p><p>在这里按c,再按p，再反汇编就可以得到我们的加密函数了</p><p><img lazyload="" src="/images/loading.svg" data-src="/2022/12/21/tuo-ke/image-20221227103659899.png" alt="image-20221227103659899"></p><hr><p>通过这两到题，我们大致可以发现，upx脱壳，就是去寻找可疑点，jmp,或者ret，因为壳是一个程序，因此我们脱壳就是要其运行完成的结果，所以我们在脱壳过程中总是要跳到ret，也就是这个原因。最后到oep的时候也很有特点，多脱几次就有感觉了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>csapp 第二章 信息的表示和处理</title>
      <link href="/2022/12/21/csapp-di-er-zhang-xin-xi-de-biao-shi-he-chu-li/"/>
      <url>/2022/12/21/csapp-di-er-zhang-xin-xi-de-biao-shi-he-chu-li/</url>
      
        <content type="html"><![CDATA[<h1 id="信息的表示和处理"><a href="#信息的表示和处理" class="headerlink" title="信息的表示和处理"></a>信息的表示和处理</h1><p><strong>本章的话，深入的讲解了我们的数据（信息）是如何在内存中表示，以及存储，后面的部分主要是讲解了我们的整数与浮点数的存储与运算，并且在数学上进行了证明与推导。总的来说，在数学证明与推导上，有点晦涩难懂（数学太菜了）。而且在一定程度上，我们平常也用不到这个，我们只需要了解一下就行了，重点关注比较常用的知识点</strong></p><h3 id="信息存储"><a href="#信息存储" class="headerlink" title="信息存储"></a>信息存储</h3><p><strong>信息是怎么表示？</strong> 我们知道，我们的信息是由位组成的，我们的位就是0,1的集合，这样的表示被成为二进制，由于0101010这样相对于我们人类的十进制，太难理解和阅读了，为了更加简便，人们就思考怎样可以更加简便？因此找到了十六进制来表示。二进制和十六进制的转换很简单而且直观。</p><p><strong>我们存储数据的大小是多少呢？</strong> 我们应该知道的是，在不同的计算机上，我们的一些数据的大小存储是不同的，比如，我们熟悉的int ，在不同的计算机上有的是占4个字节（大多数），有的计算机上占的是2个字节。因此在讨论所占大小时我们应该考虑计算机本身的存储。下面就是32位，与64位的一些区别。</p><p><img lazyload="" src="/images/loading.svg" data-src="/2022/12/21/csapp-di-er-zhang-xin-xi-de-biao-shi-he-chu-li/image-20221222221354739.png" alt="image-20221222221354739"></p><p><strong>有一个需要注意的点就是，64位的计算机能够兼容32位的程序，也就是说32位的程序能在64位上跑，64位不的能在32位上跑</strong></p><p><strong>内存中如何排列这些字节序？</strong> 在不同的计算机中对于字节的排序是不同的，因而对于同一个文本，它的解释方式是不一样的。计算机有两种方式，一个是大端法，一个是小端法。对于大小端可以这样记，所谓大端就是大的位存储在前面（也就是低位），小端就是小的位存储在前面。比如1234，有空间0xa,0xb,0xc,0xd。按照大端存储就是1放在0xa,2放在0xb,3放在0xc,4放在0xd.按照小端排序的话，4放在0xa,3放在0xb,2放在0xc,1放在0xd.</p><p><strong>布尔代数</strong> </p><p>这个就只有两个，一个是ture，一个是false。就是真和假，和我们高中学的知识一样，或，且，非，异或，四中逻辑运算。因为ture和false,刚好和我们的存储的二进制0,1对应，因此计算机上运用广泛。</p><p><strong>位运算和逻辑运算</strong> </p><p>主要区别就是位运算处理的是数据运算，而逻辑运算处理的是一种判断，真假。</p><p><em><strong>位运算</strong></em> </p><p><img lazyload="" src="/images/loading.svg" data-src="/2022/12/21/csapp-di-er-zhang-xin-xi-de-biao-shi-he-chu-li/image-20221223002053291.png" alt="image-20221223002053291"></p><p><em><strong>逻辑运算</strong></em></p><p><img lazyload="" src="/images/loading.svg" data-src="/2022/12/21/csapp-di-er-zhang-xin-xi-de-biao-shi-he-chu-li/image-20221223002128217.png" alt="image-20221223002128217"></p><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><p><strong>整数的数据类型</strong> </p><p>对于整数来说，整数可以分为有符号数和无符号数。在不同的机器上，我们的整数的表示范围有着不同的差别。</p><p><em><strong>32位机器上</strong></em> </p><p><img lazyload="" src="/images/loading.svg" data-src="/2022/12/21/csapp-di-er-zhang-xin-xi-de-biao-shi-he-chu-li/image-20221223120246269.png" alt="image-20221223120246269"></p><p><em><strong>64位机器上</strong></em> </p><p><img lazyload="" src="/images/loading.svg" data-src="/2022/12/21/csapp-di-er-zhang-xin-xi-de-biao-shi-he-chu-li/image-20221223120356826.png" alt="image-20221223120356826"></p><p>这个我们可以发现一个问题，有符号数的负数比整数多表示了一个数，这里是因为有一个整数用来表示0去了。</p><ul><li>我们大多数机器都是用补码的形式来表示有符号整数</li><li>对于强制转换类型，是保持位不变改变了解释这些位的解释方式。也就是说存储的数据（0，1）并没有改变，仅仅是解释的方式变了，上下文变了。</li><li>大多数数字是默认有符号的，如果要创建无符号常量就需要在数字后面加上一个u。</li><li>强制转换有显式和隐式的，显式强制转换在前面加括号，在写上要转换的类型。隐式强制转换，由编译器自动进行。比如printf中，一个int型，打印用%x，就是隐式转换。</li><li>一个小的数据类型，可以转换为一个交大的数据类型（对位进行扩展），而一个大的数据类型，可能转换不到较小的去（对数字进行截断），因为可能会发生溢出。</li><li>乘法，与除法，在机器上运行是很慢的，我们可以通过位运算，加法和减法的组合运算来实现，从而提高速度。</li></ul><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p><strong>舍入</strong> </p><p>对于一个浮点数，或者说对于一个小数，我们计算机是怎么取舍的呢？如果我们学习过c语音可以知道，浮点数是有精度的，也就是说我们的数都是由无限逼近的数进行取舍的，也就是说，举个例子：5/2=2.5，在我们的计算机中这个2.5并不是准确的2.5，可能是2.49876765.有些时候可能我们会纳闷，有些时候计算机是进行的四舍五入，有些时候我们的计算机又进行的是直接抹除小数后面位数。那么到底是怎么取舍的呢？通常情况下我们采取的舍入规则是在原来的值是舍入值的中间值时，采取向偶数舍入（四舍五入）<strong>而它的原理</strong> 二进制中，末尾为0的数为偶数。而若不是这样的话，我们的计算机一般会有选择性的使用向上和向下舍入，但最终还是会向最接近的值舍入。这是IEEE采取的默认的舍入方式，因为这种舍入方式总是向最近的值的舍入，从而让我们的舍入更加精确。也就是大部分都是四舍五入，只有下面的一种是向零舍入。</p><p><strong>浮点运算</strong> </p><p>这里我们需要知道：</p><ul><li>浮点运算没有结合律和分配律，打个比方（3-3）+0.0000000000002=0.00000000000002，（3+0.0000000000002）-3=0，按照我们的数学来说很奇怪是不是？出现这个的原因，就是因为浮点数有着舍入与精度规则，第二个式子的值被抹去了。</li></ul><p>对此推广开来，我们就可以知道一些问题：</p><ul><li>int转换成float，不会发生溢出，但是可能会发生舍入。</li><li>double转换成int，与float，可能会发生溢出。</li><li><strong>由浮点数转换为整数，float,double,转换成int会发生取舍，取舍规则为向零取舍，即小数点后面的数全部抹除</strong></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>cs:app 第一章 计算机系统漫游</title>
      <link href="/2022/12/15/csapp-di-yi-zhang-ji-suan-ji-xi-tong-man-you/"/>
      <url>/2022/12/15/csapp-di-yi-zhang-ji-suan-ji-xi-tong-man-you/</url>
      
        <content type="html"><![CDATA[<h1 id="cs-app-第一章-计算机系统漫游"><a href="#cs-app-第一章-计算机系统漫游" class="headerlink" title="cs:app 第一章 计算机系统漫游"></a>cs:app 第一章 计算机系统漫游</h1> <div class="wb"><div class="t">  </div><div class="c">本章总的来说是本书的一个引入，通过我们所写的一个.c文件由书写到执行的全过程中所经历的历程，从而对于计算机系统的总体进行一个一个大致的描述，和概念的提出，起到一个抛砖引玉的效果。     </div> </div><h3 id="1-1信息就是位-上下文"><a href="#1-1信息就是位-上下文" class="headerlink" title="1.1信息就是位+上下文"></a>1.1信息就是位+上下文</h3><p>这里提到了信息是由位+上下文。那么什么是位呢？什么又是上下文呢？</p><p>我们的所写的程序，本质上都是由值0和1组成的位（bit 比特）。这就是所谓的位，而8个位组成一组，我们称之为字节。而字节可以表示程序的一些文本字符，一群文本字符的集合构成了我们的程序。</p><blockquote><p>大部分的现代计算机系统都使用ASCII标准来表示文本字符。只由ASCII字符构成的文件称为文本文件，所有其他文件都称为二进制文件。</p></blockquote><p>到此我们可以知道了，我们数据就是一串串的比特来表示的。然而面对众多数据，例如：我们的程序数据，我们网上邮箱的数据，我们打游戏而储存的数据……等等，如何区别这些信息（数据）呢？这个时候就需要了解这些数据对象的上下文。在不同的的上下文中，同一个数据，可能表示为数值，可能表示字符串（英文，汉字等），也可能表示某条指令。</p><p>因此我们说位（比特）与该数据对象的上下文构成了信息。</p><h3 id="1-2程序被其他程序翻译成不同的格式"><a href="#1-2程序被其他程序翻译成不同的格式" class="headerlink" title="1.2程序被其他程序翻译成不同的格式"></a>1.2程序被其他程序翻译成不同的格式</h3><p>对于我们写的第一个程序hello，我们得到的是hello.c的文件，而要到我们所执行的hello.exe可执行文件就需要经过一系列的路程，在这个过程中我们的程序就会被翻译成不同的格式。</p><p><img lazyload="" src="/images/loading.svg" data-src="/2022/12/15/csapp-di-yi-zhang-ji-suan-ji-xi-tong-man-you/image-20221214130847881.png" alt="image-20221214130847881"></p><p>具体有四个过程：</p><ul><li>预处理阶段。将我们.c文件里面的对#开头的命令，例如引用的文件，define 的数据等，插入到文本中，得到.i文件。</li><li>编译阶段。编译器将我们的.i文本翻译成汇编语言。文件由.i变成.s.</li><li>汇编阶段。汇编器将我们的.s文本翻译成机器语言指令（0，1），如何把这些指令打包成可重定位目标程序。到这里.s文件变成了.o文件。这里得到的.o文件属于二进制文件。</li><li>链接阶段。在我们程序中引用了c语言的库函数。而这个时候链接器就将我们引用的库函数，链接合并到我们的文件中。到此处.o文件转化成了.exe文件。</li></ul><p>.exe就可以加载到内存中，由系统执行了。</p><h3 id="1-3了解编译系统的益处"><a href="#1-3了解编译系统的益处" class="headerlink" title="1.3了解编译系统的益处"></a>1.3了解编译系统的益处</h3><ul><li>优化程序性能</li><li>理解链接时出现的错误</li><li>避免安全漏洞</li></ul><h3 id="1-4处理器读并解释储存在内存中的指令"><a href="#1-4处理器读并解释储存在内存中的指令" class="headerlink" title="1.4处理器读并解释储存在内存中的指令"></a>1.4处理器读并解释储存在内存中的指令</h3><p>当我们运行.exe文件的时候，这个时候就需要我们的系统进行进行执行，而我们的系统是由硬件组成的，在的硬件配合才能成功的执行我们的.exe文件。首先这里我们要了解我们系统的硬件组成，以及其运行原理。</p><p><strong>硬件组成</strong></p><ol><li><p><strong>总线</strong></p><p>贯穿整个系统的是一组电子管道，称作总线，它 携带信息字节并负责在各个部件间传递。</p></li></ol><p>总线就像我们的公路一般，起到连接作用。</p><ol start="2"><li><p><strong>I/O设备</strong></p><p>I/O（即in与out的缩写，输入/输出），I/O设备就是我们与计算机进行交互的通道。常见的输入设备：鼠标，键盘，USB..等等；输出设备：显示屏，磁盘驱动器。</p><p>这里需要提到的是每个I/O设备都通过一个控制器与适配器与I/O总线相连。控制器与适配器的区别。</p><blockquote><p>控制器是I/O设备本身或者系统的主印制电路板（主板）：适配器是一块插在主板插槽上的卡。</p></blockquote><p>3.<strong>主存</strong></p><p>主存是一个临时储存设备，在程序运行时用来存放程序和程序处理的数据。这个就像是我们做菜的菜板，将要处理的东西临时的放在上面。</p><p>4.<strong>处理器</strong></p><p>中央处理单元（cpu）,即为处理器。作用是解释或者执行存储在主存中的指令引擎。而它的核心是寄存器，又称程序计数器。它的特点是时刻指向主存中的某条机器语言指令。处理器从通电开始，就时刻的在执行寄存器指向的指令。CPU在指令的要求下大致会执行一下操作：</p><blockquote><ul><li><strong>加载</strong> ：从主存复制一个字节或者一个字到寄存器中，以覆盖寄存器原来的内容。</li><li><strong>存储</strong> ：从寄存器复制一个字符或者一个字到主存的某个位置，以覆盖寄存器原来的内容。</li><li><strong>操作</strong> ：把两个寄存器的内容复制到ALU（算术/逻辑单元），ALU对这两个字做算术运算，并将结果存放到一个寄存器中，以覆盖该寄存器中原来的内容。</li><li><strong>跳转</strong>：从指令本身中抽取一个字，并将这个字复制到程序计数（PC）中，以覆盖PC中原来的值。</li></ul></blockquote></li></ol><p>上面就是对于主要硬件的大致介绍，通过硬件的配合，我们的程序就能运行起来了。</p><h3 id="1-5高速缓存至关重要"><a href="#1-5高速缓存至关重要" class="headerlink" title="1.5高速缓存至关重要"></a>1.5高速缓存至关重要</h3><p>为什么说高速缓存至关重要呢？通过上面硬件的流程我们可以知道，程序的机器指令到运行的时候，要经过多次复制，为了提高性能，系统设计者需要设计一个东西使得复制操作尽快完成。然而加快处理器的运行速度比加快主存的运行速度要容易和便宜得多，也就说优化处理器性价比更高，从而系统设计者采用了高速缓存存储器（高速缓存），利用高速缓存的局部性原理，来提高性能。因而我们能够利用高速缓存将程序的性能提高一个数量级。</p><h3 id="1-6存储设备形成层次结构"><a href="#1-6存储设备形成层次结构" class="headerlink" title="1.6存储设备形成层次结构"></a>1.6存储设备形成层次结构</h3><p>计算机系统的存储设备都被组织成了一个存储器层次结构，如图，从上到下设备的访问速度越来越慢，而容量越来越大，造价也越来越便宜。</p><p><img lazyload="" src="/images/loading.svg" data-src="/2022/12/15/csapp-di-yi-zhang-ji-suan-ji-xi-tong-man-you/image-20221214181429916.png" alt="image-20221214181429916"></p><p>我们可以通过利用对整个存储器层次结构的理解来提高程序性能。</p><h3 id="1-7操作系统管理硬件"><a href="#1-7操作系统管理硬件" class="headerlink" title="1.7操作系统管理硬件"></a>1.7操作系统管理硬件</h3><p>当我们运行输入命令或者运行程序的时候，其实他们并不是直接去访问我们的硬件的（键盘，显示器 等），而是需要通过一个“媒介”——操作系统。可以这样说，所有应用程序对应硬件的操作尝试都通过操作系统。这里的操作系统就好比一个对于程序与硬件的管理者，一个方面防止硬件被失控的应用程序滥用，另一方面向应用程序提供简单一致的机制来控制复制而又不相同的低级硬件设备。而操作系统通过，进程，虚拟内存，文件，这三个方面实现的。</p><h6 id="进程与线程"><a href="#进程与线程" class="headerlink" title="#进程与线程"></a>#进程与线程</h6><p>什么是进程呢？所谓进程就是操作系统对于一个正在运行的程序的一种抽象，换个方式来理解，一个程序从开始运行到结束这个过程，就是进程。而进程又是由线程组成的，线程指的就是我们程序里面一个个的执行单元。举个例子，当你打开音乐播放器，将音乐播放器运行起来，这个时候，就相当于一个进程，这个时候，你想听歌，这就相当于一个线程，如果你想在听歌的时候同时把歌曲下载下来，这个时候就变成了所谓的多线程。</p><h6 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="#虚拟内存"></a>#虚拟内存</h6><p>我们都知道我们的内存是有限，当我们运行多个进程的时候，就有可能出现主存不足的情况，因此虚拟空间就出现了。虚拟空间的作用就是创建一个更大的连续的空间——利用一部分磁盘的空间。由于是由主存和磁盘上空间上的，物理上并不是连续的，但是逻辑是连续的，虚拟一词就由此而来。</p><p>虚拟空间大致组成就如下图一般：</p><p><img lazyload="" src="/images/loading.svg" data-src="/2022/12/15/csapp-di-yi-zhang-ji-suan-ji-xi-tong-man-you/image-20221216233613136.png" alt="image-20221216233613136"></p><blockquote><ul><li><strong>程序代码和数据</strong> 。正如其名，这里面就是我们所写的代码和一些数据。</li><li><strong>堆</strong> 这里是我们个人可以管理的空间，比如，c语言中的malloc申请一片空间，free释放一片空间。</li><li><strong>共享库</strong> 这里面存放的是我们的一些c语言库，数学库等等，一些库的代码和数据。</li><li><strong>栈</strong> 这是由编译器管理的空间。存储着我们调用的函数，设置的变量和一些对象的引用，等等，由编译器分配。</li><li><strong>内核存虚拟内存</strong> 系统内核区域</li></ul></blockquote><h6 id="文件"><a href="#文件" class="headerlink" title="#文件"></a>#文件</h6><p>文件就是字节序列。就是一堆0,1构成的的集合体。万物皆文件，在系统里面的所有数据我们都可以称之为文件。</p><h3 id="1-8系统之间利用网络通信"><a href="#1-8系统之间利用网络通信" class="headerlink" title="1.8系统之间利用网络通信"></a>1.8系统之间利用网络通信</h3><p>我们的个人计算机，就是一个单独的系统，然而我们的计算机可以通过网络实现对于其他计算机的连接，这样我们单独的系统就可以连进一个大家庭了。利用网路完成信息的交互。实现上网。</p><p>比如我们去b站看视频。大致过程就是，我们本地的客户端，向着远程的服务端进行传输数据，发送我们的视频请求，服务端接收到数据之后，经过一系列的操作，将我们所请求的视频数据返回到我们本地的客服端，我们接收之后，客户端进行操作，然后显示到我们的显示屏上，这样我们就可以看到视频的内容了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/12/15/xin-pian-zhang/"/>
      <url>/2022/12/15/xin-pian-zhang/</url>
      
        <content type="html"><![CDATA[<h2 id="第一次搭建博客记录一下"><a href="#第一次搭建博客记录一下" class="headerlink" title="第一次搭建博客记录一下"></a>第一次搭建博客记录一下</h2><p>2022.12.15，记录一下二木的博客小屋的诞生。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
